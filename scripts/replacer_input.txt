=== PROCESSED: 2025-06-23 15:21:24 ===
SUCCESS Block 1: Updated /Users/stuart/repos/csl-parser/csl-parser/main/core/src/parser.ts
SUCCESS Block 2: Updated /Users/stuart/repos/csl-parser/csl-parser/main/core/src/parser.ts
===

You're right - I need to look at the actual code. I see the issue now. The edits I suggested aren't applied in the code you pasted. Let me trace through what needs to happen:

The problem is in this section where we check if a line starts with the delimiter but doesn't match the full marker regex:

```typescript
} else {
  // Line starts with delimiter but doesn't match pattern
  console.log(`  Marker regex failed to match`);
  console.log(`  Current state: ${state}`);
  if (!state || state === 'TASKS') {
    // At top level - this is an error
    console.log(`  Throwing malformed marker error`);
    throw new Error(`Line ${lineNum}: Malformed marker`);
  }
  // In content block - treat as literal content
  console.log(`  In content block - treating as literal content`);
}
```

For the test case `<---END---> extra text`, we need to detect that this is a valid marker pattern with trailing content BEFORE we decide to treat it as literal content.

Here are the corrected edits:

<<<EXPLANATION>>>
Add a helper function to check if an operation is valid for the current state. This will be used to determine if we should throw a "content on marker line" error.

<<<FILE>>>
csl-parser/main/core/src/parser.ts

<<<SEARCH>>>
export function parse(text: string, options?: ParseOptions): Operation[] {
  const startDelim = options?.startDelimiter || '<---';
  const endDelim = options?.endDelimiter || '--->';
  
  // Escape special regex characters
  const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const startEscaped = escapeRegex(startDelim);
  const endEscaped = escapeRegex(endDelim);
  
  // Build regex for markers: ^<---(\w+)(\s+(.*))?--->$
  const markerRegex = new RegExp(`^${startEscaped}(\\w+)(\\s+(.*))?${endEscaped}$`);
<<<REPLACE>>>
export function parse(text: string, options?: ParseOptions): Operation[] {
  const startDelim = options?.startDelimiter || '<---';
  const endDelim = options?.endDelimiter || '--->';
  
  // Escape special regex characters
  const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const startEscaped = escapeRegex(startDelim);
  const endEscaped = escapeRegex(endDelim);
  
  // Build regex for markers: ^<---(\w+)(\s+(.*))?--->$
  const markerRegex = new RegExp(`^${startEscaped}(\\w+)(\\s+(.*))?${endEscaped}$`);
  
  // Helper to check if an operation is valid for current state
  const isValidOperationForState = (opName: string, currentState: string | null): boolean => {
    if (!currentState) {
      // At top level - only operation starters are valid
      return ['WRITE', 'RUN', 'SEARCH', 'TASKS'].includes(opName);
    } else if (currentState === 'TASKS') {
      // In TASKS - operation starters and END are valid
      return ['WRITE', 'RUN', 'SEARCH', 'END'].includes(opName);
    } else if (currentState === 'WRITE' || currentState === 'RUN') {
      return opName === 'END';
    } else if (currentState === 'SEARCH_PATTERN') {
      return ['TO', 'REPLACE', 'END'].includes(opName);
    } else if (currentState === 'SEARCH_TO') {
      return opName === 'REPLACE';
    } else if (currentState === 'SEARCH_REPLACEMENT') {
      return opName === 'END';
    }
    return false;
  };
<<<END>>>

<<<EXPLANATION>>>
Now modify the section that handles lines starting with the delimiter but not matching the full regex. We need to check if it's a valid marker with trailing content before deciding to treat it as literal content.

<<<FILE>>>
csl-parser/main/core/src/parser.ts

<<<SEARCH>>>
      } else {
        // Line starts with delimiter but doesn't match pattern
        console.log(`  Marker regex failed to match`);
        console.log(`  Current state: ${state}`);
        if (!state || state === 'TASKS') {
          // At top level - this is an error
          console.log(`  Throwing malformed marker error`);
          throw new Error(`Line ${lineNum}: Malformed marker`);
        }
        // In content block - treat as literal content
        console.log(`  In content block - treating as literal content`);
      }
<<<REPLACE>>>
      } else {
        // Line starts with delimiter but doesn't match pattern
        console.log(`  Marker regex failed to match`);
        console.log(`  Current state: ${state}`);
        
        // Check if this looks like a marker with trailing content
        // Build a regex that matches up to and including the end delimiter
        const partialMarkerRegex = new RegExp(`^${startEscaped}(\\w+)(\\s+(.*))?${endEscaped}`);
        const partialMatch = line.match(partialMarkerRegex);
        
        if (partialMatch) {
          const opName = partialMatch[1];
          console.log(`  Found partial marker: ${opName}`);
          
          // Check if this would be a valid state-transition marker for current state
          const wouldBeValidMarker = isValidOperationForState(opName, state);
          console.log(`  Would be valid marker: ${wouldBeValidMarker}`);
          
          // If it would be a valid marker but has trailing content, that's an error
          if (wouldBeValidMarker && line.length > partialMatch[0].length) {
            console.log(`  Has trailing content after valid marker`);
            throw new Error(`Line ${lineNum}: Content not allowed on marker line`);
          }
        }
        
        if (!state || state === 'TASKS') {
          // At top level - this is an error
          console.log(`  Throwing malformed marker error`);
          throw new Error(`Line ${lineNum}: Malformed marker`);
        }
        // In content block - treat as literal content
        console.log(`  In content block - treating as literal content`);
      }
<<<END>>>

The key changes:
1. Added `isValidOperationForState` helper function that correctly identifies which operations are valid for each state
2. When a line starts with the delimiter but doesn't match the full regex, we now:
   - Check if it matches a partial marker pattern (marker without line end requirement)
   - Check if that operation would be valid for the current state
   - If both are true AND there's content after the marker, throw "Content not allowed on marker line"

This should fix the test case where `<---END---> extra text` in a WRITE block should throw "Content not allowed on marker line" instead of being treated as literal content.