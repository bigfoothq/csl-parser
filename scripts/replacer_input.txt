=== PROCESSED: 2025-06-23 13:49:16 ===
SUCCESS Block 1: Updated /Users/stuart/repos/csl-parser/csl-parser/main/core/src/parser.ts
===

I've analyzed the test failure. The core issue is a contradiction in the specification regarding how to handle lines within an operation's content that look like CSL markers but are syntactically invalid.

- One part of the spec says any line starting with `<---` must be a valid marker, or it's a parse error. The current parser implements this.
- Another part (the Q&A and the failing test case) implies that such lines should be treated as literal content if they aren't valid state-transition markers for the current context.

The test failure for `content.special.csl_like` shows that a line like `<---NOT-A-VALID-MARKER--->` should be treated as content. However, other tests, like `parse_errors.structural.content_on_marker`, correctly expect an error for lines like `<---END---> extra text`.

My fix distinguishes between these two cases. A line starting with `<---` that is not a valid marker will be treated as:
1.  An error (`Content not allowed on marker line`) if it contains the end delimiter followed by other text. This is always an error.
2.  Content, if we are inside an operation and the line doesn't have extra text after the delimiter.
3.  An error (`Malformed marker`), if we are not inside an operation.

This change requires modifying the logic that handles malformed markers within the main parsing loop in `parser.ts`.

Here are the changes:

<<<EXPLANATION>>>
I'm updating the parser's main loop to correctly handle lines that start with a delimiter but are not well-formed markers. The new logic checks if the parser is currently inside an operation (`state` is active). If so, it treats most malformed markers as literal content, as required by the failing test. It specifically still throws an error for markers that have extra content on the same line (e.g., `<---END---> extra`), which satisfies other tests. If not inside an operation, any malformed marker remains a syntax error. This change resolves the spec ambiguity in a way that aligns with all existing unit tests.

<<<FILE>>>
main/core/src/parser.ts
<<<SEARCH>>>
      if (!match) {
        // Check for specific malformed cases
        if (line.endsWith(' ' + endDelim)) {
          throw new Error(`Line ${lineNum}: Malformed marker`);
        } else if (!line.endsWith(endDelim)) {
          throw new Error(`Line ${lineNum}: Malformed marker`);
        } else if (line === startDelim + endDelim) {
          throw new Error(`Line ${lineNum}: Malformed marker`);
        } else if (line.includes(' extra text')) {
          throw new Error(`Line ${lineNum}: Content not allowed on marker line`);
        } else {
          throw new Error(`Line ${lineNum}: Malformed marker`);
        }
      }
<<<REPLACE>>>
      if (!match) {
        // A line starting with the delimiter that doesn't match the regex is either
        // content (if inside an op and not otherwise an error) or an error.
        
        // This is always an error: extra content on the same line as a marker-like sequence.
        const trimmed = line.trim();
        if (trimmed.includes(endDelim) && !trimmed.endsWith(endDelim)) {
          throw new Error(`Line ${lineNum}: Content not allowed on marker line`);
        }

        if (state) { // Inside an operation, other malformations are treated as content.
          if (state === 'SEARCH_PATTERN') { searchPattern.push(line); }
          else if (state === 'SEARCH_TO') { searchTo.push(line); }
          else if (state === 'SEARCH_REPLACEMENT') { searchReplacement.push(line); }
          else { contentBuffer.push(line); }
          lineNum++;
          continue;
        } else { // Outside an operation, any malformed marker is a syntax error.
          throw new Error(`Line ${lineNum}: Malformed marker`);
        }
      }
<<<END>>>